{
  "id": "yhdm-one",
  "name": "樱花动漫",
  "version": "1.0.0",
  "description": "樱花动漫 yhdm.one 在线观看提供商，支持中文动漫内容",
  "author": "IKUN",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "zh-CN",
  "icon": "https://github.com/JiangJunLigth/seanime-extensions/raw/main/yhdm/logo.jpg",
  "website": "https://yhdm.one",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n  private baseUrl = \"https://yhdm.one\";\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"默认播放器\", \"备用播放器\"],\n      supportsDub: false, // 樱花动漫主要是中文字幕，不支持配音切换\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    const normalize = (str: any) =>\n      safeString(str).toLowerCase().replace(/[^a-z0-9\\u4e00-\\u9fff]+/g, \"\"); // 支持中文字符\n\n    // 安全地获取目标标题\n    const romajiTitle = query.media?.romajiTitle || query.query || \"\";\n    const englishTitle = query.media?.englishTitle || \"\";\n    \n    const targetNorm = normalize(romajiTitle);\n    const targetNormEN = englishTitle ? normalize(englishTitle) : targetNorm;\n\n    try {\n      // 使用网站搜索功能 - 使用安全的查询字符串\n      const searchQuery = query.query || romajiTitle || \"动漫\";\n      const searchUrl = `${this.baseUrl}/search?q=${encodeURIComponent(searchQuery)}`;\n      const html = await fetch(searchUrl, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n          \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n          \"Accept-Language\": \"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\",\n        },\n      }).then(res => res.text());\n\n      const matches = this.parseSearchResults(html);\n      \n      if (matches.length === 0) {\n        // 尝试分类页面搜索\n        return await this.searchByCategory(searchQuery);\n      }\n\n      // 匹配最佳结果\n      const levenshtein = (a: string, b: string) => {\n        const dp: number[][] = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));\n        for (let i = 0; i <= a.length; i++) dp[i][0] = i;\n        for (let j = 0; j <= b.length; j++) dp[0][j] = j;\n        for (let i = 1; i <= a.length; i++) {\n          for (let j = 1; j <= b.length; j++) {\n            dp[i][j] =\n              a[i - 1] === b[j - 1]\n                ? dp[i - 1][j - 1]\n                : 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n          }\n        }\n        return dp[a.length][b.length];\n      };\n\n      // 寻找最佳匹配\n      let best = matches.find(m => \n        normalize(m.title).includes(targetNorm) || targetNorm.includes(normalize(m.title))\n      );\n\n      if (!best && targetNormEN !== targetNorm) {\n        best = matches.find(m => \n          normalize(m.title).includes(targetNormEN) || targetNormEN.includes(normalize(m.title))\n        );\n      }\n\n      // 如果没有找到部分匹配，使用编辑距离\n      if (!best) {\n        matches.sort((a, b) => \n          levenshtein(normalize(a.title), targetNorm) - levenshtein(normalize(b.title), targetNorm)\n        );\n        best = matches[0];\n      }\n\n      if (!best) return [];\n\n      return [{\n        id: best.id,\n        title: best.title,\n        url: best.url,\n        subOrDub: \"sub\",\n      }];\n\n    } catch (error) {\n      console.error(\"搜索失败:\", error);\n      return [];\n    }\n  }\n\n  private parseSearchResults(html: string): any[] {\n    const results: any[] = [];\n    \n    // 匹配动漫链接和标题\n    const linkRegex = /<a[^>]+href=\"\\/vod\\/(\\d+)\\.html\"[^>]*>([^<]+)<\\/a>/g;\n    let match;\n    \n    while ((match = linkRegex.exec(html)) !== null) {\n      const id = match[1];\n      const title = match[2].trim();\n      \n      results.push({\n        id: id,\n        title: title,\n        url: `${this.baseUrl}/vod/${id}.html`,\n      });\n    }\n\n    // 如果上述正则没匹配到，尝试其他模式\n    if (results.length === 0) {\n      const altRegex = /<h3[^>]*><a[^>]+href=\"\\/vod\\/(\\d+)\\.html\"[^>]*>([^<]+)<\\/a><\\/h3>/g;\n      while ((match = altRegex.exec(html)) !== null) {\n        const id = match[1];\n        const title = match[2].trim();\n        \n        results.push({\n          id: id,\n          title: title,\n          url: `${this.baseUrl}/vod/${id}.html`,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  private async searchByCategory(query: string): Promise<SearchResult[]> {\n    // 如果直接搜索失败，尝试在最新更新中查找\n    try {\n      const html = await fetch(`${this.baseUrl}/latest/`, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n        },\n      }).then(res => res.text());\n\n      const matches = this.parseSearchResults(html);\n      \n      // 过滤包含查询关键词的结果\n      const filtered = matches.filter(m => \n        m.title.toLowerCase().includes(query.toLowerCase()) ||\n        query.toLowerCase().includes(m.title.toLowerCase())\n      );\n\n      return filtered.slice(0, 5).map(m => ({\n        id: m.id,\n        title: m.title,\n        url: m.url,\n        subOrDub: \"sub\",\n      }));\n    } catch (error) {\n      return [];\n    }\n  }\n\n  async findEpisodes(animeId: string): Promise<EpisodeDetails[]> {\n    try {\n      const animeUrl = `${this.baseUrl}/vod/${animeId}.html`;\n      const html = await fetch(animeUrl, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n        },\n      }).then(res => res.text());\n\n      const episodes: EpisodeDetails[] = [];\n      \n      // 匹配剧集链接\n      const episodeRegex = /<a[^>]+href=\"\\/vod-play\\/(\\d+)\\/ep(\\d+)\\.html\"[^>]*>([^<]*第(\\d+)[集话][^<]*)<\\/a>/g;\n      let match;\n\n      while ((match = episodeRegex.exec(html)) !== null) {\n        const episodeId = match[1];\n        const episodeNum = parseInt(match[2]);\n        const title = match[3].trim();\n        \n        episodes.push({\n          id: `${episodeId}/ep${episodeNum}`,\n          number: episodeNum,\n          title: title || `第${episodeNum}集`,\n          url: `${this.baseUrl}/vod-play/${episodeId}/ep${episodeNum}.html`,\n        });\n      }\n\n      // 如果上述正则没有匹配到，尝试其他模式\n      if (episodes.length === 0) {\n        const altRegex = /<a[^>]+href=\"\\/vod-play\\/([^\"]+)\"[^>]*>([^<]*)<\\/a>/g;\n        while ((match = altRegex.exec(html)) !== null) {\n          const playPath = match[1];\n          const title = match[2].trim();\n          \n          // 提取集数\n          const epMatch = playPath.match(/ep(\\d+)/);\n          if (epMatch) {\n            const episodeNum = parseInt(epMatch[1]);\n            episodes.push({\n              id: playPath,\n              number: episodeNum,\n              title: title || `第${episodeNum}集`,\n              url: `${this.baseUrl}/vod-play/${playPath}`,\n            });\n          }\n        }\n      }\n\n      // 按集数排序\n      return episodes.sort((a, b) => a.number - b.number);\n\n    } catch (error) {\n      console.error(\"获取剧集列表失败:\", error);\n      return [];\n    }\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, server: string): Promise<EpisodeServer> {\n    try {\n      // 获取播放页面\n      const html = await fetch(episode.url, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n          \"Referer\": this.baseUrl,\n        },\n      }).then(res => res.text());\n\n      // 提取视频播放地址\n      const videoUrl = await this.extractVideoUrl(html, episode.url);\n      \n      if (!videoUrl) {\n        throw new Error(\"无法提取视频播放地址\");\n      }\n\n      return {\n        server: server,\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n          \"Referer\": episode.url,\n          \"Accept\": \"*/*\",\n        },\n        videoSources: [{\n          url: videoUrl,\n          type: this.getVideoType(videoUrl),\n          quality: \"auto\",\n          subtitles: [], // 樱花动漫通常是硬字幕\n        }],\n      };\n\n    } catch (error) {\n      console.error(\"获取播放地址失败:\", error);\n      throw new Error(`无法获取 ${server} 的播放地址`);\n    }\n  }\n\n  private async extractVideoUrl(html: string, pageUrl: string): Promise<string | null> {\n    // 方法1: 查找直接的视频链接\n    let videoMatch = html.match(/(?:src|source)=[\"']([^\"']+\\.(?:mp4|m3u8|flv))[^\"']*/i);\n    if (videoMatch) {\n      return this.resolveUrl(videoMatch[1], pageUrl);\n    }\n\n    // 方法2: 查找 iframe 嵌入\n    const iframeMatch = html.match(/<iframe[^>]+src=[\"']([^\"']+)[\"'][^>]*>/i);\n    if (iframeMatch) {\n      const iframeUrl = this.resolveUrl(iframeMatch[1], pageUrl);\n      try {\n        const iframeHtml = await fetch(iframeUrl, {\n          headers: {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n            \"Referer\": pageUrl,\n          },\n        }).then(res => res.text());\n\n        // 在 iframe 中查找视频源\n        videoMatch = iframeHtml.match(/(?:src|source|file)=[\"']([^\"']+\\.(?:mp4|m3u8|flv))[^\"']*/i);\n        if (videoMatch) {\n          return this.resolveUrl(videoMatch[1], iframeUrl);\n        }\n      } catch (error) {\n        console.warn(\"无法加载 iframe 内容:\", error);\n      }\n    }\n\n    // 方法3: 查找 JavaScript 中的播放地址\n    const jsMatch = html.match(/(?:url|src|source|file)[\"']?\\s*:\\s*[\"']([^\"']+\\.(?:mp4|m3u8|flv))[^\"']*/i);\n    if (jsMatch) {\n      return this.resolveUrl(jsMatch[1], pageUrl);\n    }\n\n    // 方法4: 查找常见的播放器配置\n    const configMatch = html.match(/config\\s*=\\s*{[^}]*(?:url|src|source|file)[\"']?\\s*:\\s*[\"']([^\"']+)[^\"']*/i);\n    if (configMatch) {\n      return this.resolveUrl(configMatch[1], pageUrl);\n    }\n\n    return null;\n  }\n\n  private resolveUrl(url: string, baseUrl: string): string {\n    if (url.startsWith(\"http\")) {\n      return url;\n    }\n    if (url.startsWith(\"//\")) {\n      return \"https:\" + url;\n    }\n    if (url.startsWith(\"/\")) {\n      const base = new URL(baseUrl);\n      return `${base.protocol}//${base.host}${url}`;\n    }\n    return new URL(url, baseUrl).href;\n  }\n\n  private getVideoType(url: string): string {\n    if (url.includes(\".m3u8\") || url.includes(\"m3u8\")) {\n      return \"m3u8\";\n    }\n    if (url.includes(\".mp4\")) {\n      return \"mp4\";\n    }\n    if (url.includes(\".flv\")) {\n      return \"flv\";\n    }\n    return \"mp4\"; // 默认\n  }\n}\n\nconst safeString = (str: any) => (typeof str === \"string\" ? str : \"\");\n\nfunction normalizeSeasonParts(title: string) {\n  const s = safeString(title);\n  return s\n    .toLowerCase()\n    .replace(/[^a-z0-9\\u4e00-\\u9fff]+/g, \"\") // 保留中文字符\n    .replace(/第.*?季/g, \"\") // 移除 \"第X季\"\n    .replace(/第.*?部/g, \"\") // 移除 \"第X部\"\n    .replace(/season|cour|part/g, \"\"); // 移除英文季数标识\n}"
}
