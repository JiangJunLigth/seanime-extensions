{"id":"yhdm-deep","name":"樱花动漫","version":"1.1.0","manifestURI":"","language":"typescript","type":"onlinestream-provider","description":"樱花动漫 (Sakura Anime) provider for Seanime","author":"IKun","icon":"https://gitee.com/cai-xinyu1314/seanime-extensions/raw/main/yhdm/logo.png","website":"https://yhdm.one","lang":"zh-CN","payload":"/// \u003creference path=\"../_external/.onlinestream-provider.d.ts\" /\u003e\n/// \u003creference path=\"../_external/core.d.ts\" /\u003e\n\nclass Provider {\n    private readonly BASE_URL = 'https://yhdm.one';\n    private readonly USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';\n\n    // 服务器映射表：将设置中的服务器标识映射到实际的src_site值\n    private readonly SERVER_MAPPING: { [key: string]: string[] } = {\n        \"JY\": [\"jyzy\", \"JY\"],\n        \"XL\": [\"xlzy\", \"XL\"],\n        \"JS\": [\"jszy\", \"JS\"],\n        \"MD\": [\"mdzy\", \"MD\"],\n        \"SD\": [\"sdzy\", \"SD\", \"sdzy2\"],\n        \"LZ\": [\"lzzy\", \"LZ\"],\n        \"PP\": [\"ppzy\", \"PP\"],\n        \"HN\": [\"hnzy\", \"HN\"],\n        \"GS\": [\"gszy\", \"GS\"],\n        \"FF\": [\"ffzy\", \"FF\"]\n    };\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"JY\", \"XL\", \"JS\", \"MD\", \"SD\", \"LZ\", \"PP\", \"HN\", \"GS\", \"FF\"],\n            supportsDub: false,\n        };\n    }\n\n    async search(opts: SearchOptions): Promise\u003cSearchResult[]\u003e {\n        try {\n            let searchKeyword = opts.query;\n            \n            if (opts.media \u0026\u0026 opts.media.synonyms \u0026\u0026 opts.media.synonyms.length \u003e 0) {\n                const chineseSynonyms = opts.media.synonyms.filter(s =\u003e \n                    /[\\u4e00-\\u9fa5]/.test(s)\n                );\n                \n                if (chineseSynonyms.length \u003e 0) {\n                    searchKeyword = chineseSynonyms[0];\n                }\n            }\n            \n            const searchUrl = `${this.BASE_URL}/search?q=${encodeURIComponent(searchKeyword)}`;\n            \n            const response = await fetch(searchUrl, {\n                headers: {\n                    'User-Agent': this.USER_AGENT,\n                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n                    'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',\n                    'Referer': `${this.BASE_URL}/`,\n                },\n            });\n            \n            if (!response.ok) {\n                throw new Error(`搜索失败: ${response.status} ${response.statusText}`);\n            }\n            \n            const html = await response.text();\n            const results: SearchResult[] = [];\n            \n            const itemRegex = /\u003ca[^\u003e]*href=\"(\\/vod\\/\\d+\\.html)\"[^\u003e]*title=\"([^\"]*)\"[^\u003e]*\u003e/gi;\n            \n            let match;\n            while ((match = itemRegex.exec(html)) !== null) {\n                if (match[1] \u0026\u0026 match[2]) {\n                    const idMatch = match[1].match(/\\/(\\d+)\\.html/);\n                    if (idMatch \u0026\u0026 idMatch[1]) {\n                        results.push({\n                            id: idMatch[1],\n                            title: match[2].trim(),\n                            url: `${this.BASE_URL}${match[1]}`,\n                            subOrDub: 'sub',\n                        });\n                    }\n                }\n            }\n            \n            return results;\n            \n        } catch (error) {\n            console.error('搜索失败:', error);\n            return [];\n        }\n    }\n\n    async findEpisodes(id: string): Promise\u003cEpisodeDetails[]\u003e {\n        try {\n            const detailUrl = `${this.BASE_URL}/vod/${id}.html`;\n            console.log('正在获取详情页:', detailUrl);\n            \n            const response = await fetch(detailUrl, {\n                headers: {\n                    'User-Agent': this.USER_AGENT,\n                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n                    'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',\n                    'Referer': `${this.BASE_URL}/`,\n                },\n            });\n            \n            if (!response.ok) {\n                throw new Error(`获���详情页失败: ${response.status} ${response.statusText}`);\n            }\n            \n            const html = await response.text();\n            console.log('详情页HTML长度:', html.length);\n            \n            const episodes: EpisodeDetails[] = [];\n            \n            // 多种正则表达式模式来匹配不同的剧集链接格式\n            const episodePatterns = [\n                // 原有模式：第X集\n                /\u003ca[^\u003e]*href=\"(\\/vod-play\\/\\d+\\/ep\\d+\\.html)\"[^\u003e]*\u003e\\s*第?(\\d+)[集话]\\s*\u003c\\/a\u003e/gi,\n                // 新增模式：纯数字\n                /\u003ca[^\u003e]*href=\"(\\/vod-play\\/\\d+\\/ep(\\d+)\\.html)\"[^\u003e]*\u003e\\s*(\\d+)\\s*\u003c\\/a\u003e/gi,\n                // 新增模式：更宽泛的匹配\n                /\u003ca[^\u003e]*href=\"(\\/vod-play\\/\\d+\\/ep(\\d+)\\.html)\"[^\u003e]*\u003e([^\u003c]*)\u003c\\/a\u003e/gi,\n                // 备用模式：href在title之后\n                /\u003ca[^\u003e]*title=\"[^\"]*第?(\\d+)[集话]\"[^\u003e]*href=\"(\\/vod-play\\/\\d+\\/ep\\d+\\.html)\"[^\u003e]*\u003e/gi\n            ];\n            \n            // 尝试所有模式\n            for (const pattern of episodePatterns) {\n                let match;\n                while ((match = pattern.exec(html)) !== null) {\n                    let episodeNum: number;\n                    let episodePath: string;\n                    \n                    // 根据不同模式处理匹配结果\n                    if (pattern === episodePatterns[0]) {\n                        // 第一种模式\n                        episodePath = match[1];\n                        episodeNum = parseInt(match[2]);\n                    } else if (pattern === episodePatterns[1] || pattern === episodePatterns[2]) {\n                        // 第二、三种模式\n                        episodePath = match[1];\n                        episodeNum = parseInt(match[2]);\n                    } else {\n                        // 第四种模式\n                        episodeNum = parseInt(match[1]);\n                        episodePath = match[2];\n                    }\n                    \n                    if (!isNaN(episodeNum) \u0026\u0026 episodePath) {\n                        // 检查是否已存在相同集数\n                        const existingEpisode = episodes.find(ep =\u003e ep.number === episodeNum);\n                        if (!existingEpisode) {\n                            episodes.push({\n                                id: `${id}-${episodeNum}`,\n                                number: episodeNum,\n                                title: `第${episodeNum}集`,\n                                url: `${this.BASE_URL}${episodePath}`,\n                            });\n                            console.log(`找到剧集: 第${episodeNum}集, URL: ${episodePath}`);\n                        }\n                    }\n                }\n            }\n            \n            // 如果上述方法都没找到剧集，尝试更激进的方法\n            if (episodes.length === 0) {\n                console.log('使用备用剧集提取方法');\n                \n                // 查找所有包含数字的链接\n                const allLinksRegex = /\u003ca[^\u003e]*href=\"(\\/vod-play\\/\\d+\\/[^\"]*)\"[^\u003e]*\u003e([^\u003c]*)\u003c\\/a\u003e/gi;\n                let match;\n                \n                while ((match = allLinksRegex.exec(html)) !== null) {\n                    const href = match[1];\n                    const text = match[2].trim();\n                    \n                    // 从href中提取集数\n                    const epMatch = href.match(/\\/ep(\\d+)\\.html/);\n                    if (epMatch) {\n                        const episodeNum = parseInt(epMatch[1]);\n                        if (!isNaN(episodeNum)) {\n                            const existingEpisode = episodes.find(ep =\u003e ep.number === episodeNum);\n                            if (!existingEpisode) {\n                                episodes.push({\n                                    id: `${id}-${episodeNum}`,\n                                    number: episodeNum,\n                                    title: text || `第${episodeNum}集`,\n                                    url: `${this.BASE_URL}${href}`,\n                                });\n                                console.log(`备用方法找到剧集: 第${episodeNum}集, URL: ${href}`);\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // 如果还是没找到，尝试从页面中查找任何episode相关的信息\n            if (episodes.length === 0) {\n                console.log('尝试最后的备用方法');\n                \n                // 查找页面中所有可能的剧集信息\n                const episodeInfoRegex = /(?:第|ep|episode)[\\s]*(\\d+)(?:[集话])?/gi;\n                const episodeNumbers = new Set\u003cnumber\u003e();\n                \n                let match;\n                while ((match = episodeInfoRegex.exec(html)) !== null) {\n                    const num = parseInt(match[1]);\n                    if (!isNaN(num) \u0026\u0026 num \u003e 0 \u0026\u0026 num \u003c= 9999) {\n                        episodeNumbers.add(num);\n                    }\n                }\n                \n                // 如果找到了剧集号码，尝试构造URL\n                if (episodeNumbers.size \u003e 0) {\n                    console.log('找到可能的剧集号码:', Array.from(episodeNumbers).sort((a, b) =\u003e a - b));\n                    \n                    for (const epNum of Array.from(episodeNumbers).sort((a, b) =\u003e a - b)) {\n                        episodes.push({\n                            id: `${id}-${epNum}`,\n                            number: epNum,\n                            title: `第${epNum}集`,\n                            url: `${this.BASE_URL}/vod-play/${id}/ep${epNum}.html`,\n                        });\n                    }\n                }\n            }\n            \n            console.log(`总共找到 ${episodes.length} 个剧集`);\n            \n            // 去重并排序\n            const uniqueEpisodes = episodes.filter((ep, index, self) =\u003e \n                index === self.findIndex(e =\u003e e.number === ep.number)\n            );\n            \n            return uniqueEpisodes.sort((a, b) =\u003e a.number - b.number);\n            \n        } catch (error) {\n            console.error('获取剧集失败:', error);\n            return [];\n        }\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, server: string): Promise\u003cEpisodeServer\u003e {\n        try {\n            console.log('正在获取播放页:', episode.url);\n            \n            const response = await fetch(episode.url, {\n                headers: {\n                    'User-Agent': this.USER_AGENT,\n                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n                    'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',\n                    'Referer': `${this.BASE_URL}/`,\n                },\n            });\n            \n            if (!response.ok) {\n                throw new Error(`获取播放页失败: ${response.status} ${response.statusText}`);\n            }\n            \n            const html = await response.text();\n            \n            const videoIdMatch = episode.url.match(/\\/(\\d+)\\/ep(\\d+)\\.html/);\n            if (!videoIdMatch) {\n                throw new Error('无法从URL提取视频ID和剧集号');\n            }\n            \n            const videoId = videoIdMatch[1];\n            const epNum = videoIdMatch[2];\n            \n            console.log(`视频ID: ${videoId}, 剧集号: ${epNum}`);\n            \n            const playsUrl = `${this.BASE_URL}/_get_plays/${videoId}/ep${epNum}`;\n            console.log('获取播放源:', playsUrl);\n            \n            const playsResponse = await fetch(playsUrl, {\n                headers: {\n                    'User-Agent': this.USER_AGENT,\n                    'Accept': 'application/json, text/javascript, */*; q=0.01',\n                    'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',\n                    'Referer': episode.url,\n                    'X-Requested-With': 'XMLHttpRequest',\n                },\n            });\n            \n            if (!playsResponse.ok) {\n                throw new Error(`获取播放源失败: ${playsResponse.status} ${playsResponse.statusText}`);\n            }\n            \n            const playsData = await playsResponse.json();\n            console.log('播放源数据:', playsData);\n            \n            if (!playsData.video_plays || playsData.video_plays.length === 0) {\n                throw new Error('未找到播放源');\n            }\n            \n            // 修复的服务器匹配逻辑\n            const serverPatterns = this.SERVER_MAPPING[server] || [server.toLowerCase()];\n            const selectedSource = playsData.video_plays.find((source: any) =\u003e {\n                return serverPatterns.some(pattern =\u003e \n                    source.src_site \u0026\u0026 source.src_site.toLowerCase() === pattern.toLowerCase()\n                );\n            });\n            \n            if (!selectedSource) {\n                // 尝试备用方案：返回第一个可用的播放源\n                console.warn(`未找到指定的播放源: ${server}, 尝试使用第一个可用源`);\n                const firstSource = playsData.video_plays[0];\n                if (!firstSource) {\n                    throw new Error(`未找到播放源: ${server}`);\n                }\n                console.log(`使用备用播放源: ${firstSource.src_site}, Play Data: ${firstSource.play_data}`);\n                return this.processVideoSource(firstSource, episode.url);\n            }\n            \n            console.log(`找到播放源: ${selectedSource.src_site}, Play Data: ${selectedSource.play_data}`);\n            return this.processVideoSource(selectedSource, episode.url);\n            \n        } catch (error) {\n            console.error('获取视频源失败:', error);\n            throw new Error(`无法获取视频源: ${error.message}`);\n        }\n    }\n\n    // 处理视频源提取的辅助方法\n    private async processVideoSource(source: any, referer: string): Promise\u003cEpisodeServer\u003e {\n        const videoUrl = `${this.BASE_URL}/_player_x_/${source.play_data}`;\n        console.log('视频URL:', videoUrl);\n        \n        const videoResponse = await fetch(videoUrl, {\n            headers: {\n                'User-Agent': this.USER_AGENT,\n                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n                'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',\n                'Referer': referer,\n            },\n        });\n        \n        if (!videoResponse.ok) {\n            // 如果获取代理页面失败，直接使用原始播放数据\n            console.warn(`获取视频页面失败，直接使用原始播放数据: ${videoResponse.status}`);\n            return {\n                server: source.src_site,\n                headers: {\n                    'Referer': this.BASE_URL,\n                    'User-Agent': this.USER_AGENT,\n                    'Origin': this.BASE_URL\n                },\n                videoSources: [{\n                    url: source.play_data,\n                    type: source.play_data.includes('.m3u8') ? 'm3u8' : 'mp4',\n                    quality: 'auto',\n                    subtitles: []\n                }]\n            };\n        }\n        \n        const videoHtml = await videoResponse.text();\n        const videoSources = this.extractVideoSources(videoHtml);\n        \n        if (videoSources.length === 0) {\n            // 如果无法提取视频源，直接使用原始播放数据\n            console.warn('无法从视频页面提取视频源，直接使用原始播放数据');\n            return {\n                server: source.src_site,\n                headers: {\n                    'Referer': this.BASE_URL,\n                    'User-Agent': this.USER_AGENT,\n                    'Origin': this.BASE_URL\n                },\n                videoSources: [{\n                    url: source.play_data,\n                    type: source.play_data.includes('.m3u8') ? 'm3u8' : 'mp4',\n                    quality: 'auto',\n                    subtitles: []\n                }]\n            };\n        }\n        \n        return {\n            server: source.src_site,\n            headers: {\n                'Referer': videoUrl,\n                'User-Agent': this.USER_AGENT,\n                'Origin': this.BASE_URL\n            },\n            videoSources: videoSources\n        };\n    }\n\n    // 提取视频源的辅助方法\n    private extractVideoSources(html: string): VideoSource[] {\n        const sources: VideoSource[] = [];\n        \n        // 尝试匹配m3u8地址\n        const m3u8Regex = /(https?:\\/\\/[^\\\"'\\s]+\\.m3u8[^\\\"'\\s]*)/gi;\n        const m3u8Matches = html.match(m3u8Regex) || [];\n        \n        for (const url of m3u8Matches) {\n            if (!url.includes('google') \u0026\u0026 !url.includes('doubleclick')) {\n                sources.push({\n                    url: url,\n                    type: 'm3u8',\n                    quality: 'auto',\n                    subtitles: []\n                });\n                console.log('找到M3U8源:', url);\n            }\n        }\n        \n        // 尝试匹配mp4地址\n        const mp4Regex = /(https?:\\/\\/[^\\\"'\\s]+\\.mp4[^\\\"'\\s]*)/gi;\n        const mp4Matches = html.match(mp4Regex) || [];\n        \n        for (const url of mp4Matches) {\n            if (!url.includes('google') \u0026\u0026 !url.includes('doubleclick')) {\n                sources.push({\n                    url: url,\n                    type: 'mp4',\n                    quality: 'auto',\n                    subtitles: []\n                });\n                console.log('找到MP4源:', url);\n            }\n        }\n        \n        // 尝试从JavaScript变量中提取\n        const jsVarRegex = /(?:var|let|const)\\s+[^=]*[=:]\\s*[\\\"'](https?:\\/\\/[^\\\"']+\\.(?:m3u8|mp4)[^\\\"']*)[\\\"']/gi;\n        let jsVarMatch;\n        \n        while ((jsVarMatch = jsVarRegex.exec(html)) !== null) {\n            if (jsVarMatch[1]) {\n                const url = jsVarMatch[1];\n                const type = url.includes('.m3u8') ? 'm3u8' : 'mp4';\n                \n                sources.push({\n                    url: url,\n                    type: type,\n                    quality: 'auto',\n                    subtitles: []\n                });\n                console.log('从JS变量找到视频源:', url);\n            }\n        }\n        \n        return sources;\n    }\n}"}
